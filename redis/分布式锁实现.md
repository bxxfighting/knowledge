### 问题
在保护竞争资源的时候，我们一般都会加锁，我们在同一服务下，可以经常用到的是进程锁、线程锁。  
或者同一台机器下用文件锁，但是我们一般都是多台服务器运行同一服务，也就是分布式系统，  
在这种情况下，如何来保护竞争资源呢  

### 解决办法
大概解决思路：
1. 在redis中以```SET key val NX```设置，这意思是如果不存在这个key就设置，  存在就不设置。
> 比如同一个资源，我们就用统一的key，谁在调用SET的时候返回成功就是获取了锁，  
> 那么谁就获取到了这个资源的使用权。当使用完成后，就需要DEL key，就释放了锁。
2. 但是在分布式系统中，A服务器获取了锁，但是A却挂了，那么这个锁就没有人释放了，导致资源不可用。
> 这种情况是很容易预想到的，因此为了避免这种情况，在设置时增加key的超时时间。  
> ```SET key val NX PX ttl```这里ttl就是超时时长，单位为毫秒。这样在获取锁的服务挂了后，  
> 资源在过了超时时间后，又变成可用状态。  
3. 上面增加了超时时间，如果A获取到了锁，但是A使用资源的时间大于了设置的超时时间。  
这就导致锁因超时释放了，又被其它服务获取到了。等A执行完成后，又想去DEL key时，  
其实这个锁已经不属于自己了，这样就又误释放了别人的锁。  
> 出现这种情况我们就是要想办法知道这个key还是不是我们当初设置的key，因此就通过给key设置的val来解决  
> 我们把val值，弄成一个唯一值，不同服务在设置key时的val不同(可以使用uuid或者当前时间戳加客户id等)，  
> 现在我们在释放锁的时候先取key的val，然后和自己设置时的val比较，如果相同就DEL key。  
```
if (GET key == val):
    DEL key
```
> 这种处理看似好像正确，但是其实在GET key == val和DEL key两步操作之间是有时间窗口的，  
> 如果在这个时间窗口下，key已经超时，又被别人设置了，就会出现问题。  
> 这里我们需要一个原子操作（只要执行就一次性执行完），在redis中lua脚本提供了这样的能力。  

```
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```
4. 上面保证了我们不要误释放别人的锁，但是如果我们使用锁的时间超时了，别人也获取到了锁，  
那么其实这种情况下，就又出现了竞争关系。
> 这种情况，现在的解决方案就是，我们要根据我们实际的情况来设置这个超时时间  
> 其实这里可以这样想，如果一切正常的情况下，不论我们设置的超时时间有多长，  
> 我们都会在用完资源会主动释放锁的，所以不会因为超时时间设置长了，导致出问题。  
> 会出问题的情况是，获取了锁，但是锁主人挂了，这样这个超时时间就影响到了资源的使用。  

### 参考资料
[官方redis实现分布式锁文档](https://redis.io/topics/distlock)  
[参考代码实现](https://github.com/SPSCommerce/redlock-py)  
