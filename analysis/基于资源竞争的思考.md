### 问题
当计算机可以进行多任务切换后，就出现了资源竞争问题，  
而当下分布式系统当道，这种问题更是突显，那么我来整理一下各种思路。  

### 解决办法
1. 正常情况下，我们只是要更新一个属性的时候，其实是不存在竞争问题的。  
我们想一下，有一个商品名称叫“宝贝”，现在有十个人都要修改这个商品的名称，  
那么商品最后记录的名称是谁修改的都无所谓。因为商品就是记录了最后的名称。  
没有任何问题。因为就是大家同时修改，最后记录成谁的都可以。  

2. 现在在这个场景下加一个条件，我们需要记录商品修改日志，由什么名字修改成什么名字。  
这种情况下，我们在记录修改日志时，先要知道商品当前叫什么名字，才能记录此条日志。  
试想，A拿到商品名称叫“宝贝”，修改名称时，让出了CPU；然后B拿到商品名称也叫“宝贝”，  
现在不论最后商品名称最修改成了什么，都会出现两条记录，而记录中商品原始名都是“宝贝”，  
这就出现了冲突。因此这种情况下我们就需要在整个操作之前加锁，保证同时只有一个人可以修改商品名称。  
以mysql操作为示例:
```
-- 商品id: 123
-- 商品名称：宝贝
select name from goods where id = 123;
-- 这之间就存在时间窗口
update goods set name = "垃圾" where id = 123;
-- 记录日志 A修改“宝贝”到“垃圾”

-- 我们可以通过使用mysql中的锁来解决
select name from goods where id = 123 for update;
update goods set name = "垃圾" where id = 123;
```

3. 另一种情况，如果修改商品名称时有一个限制条件，只有当商品叫“宝贝”时，才允许修改名称。  
那么在2中的问题，在这里也是存在的，A拿到商品时名称叫“宝贝”，让出CPU；B拿到商品也叫“宝贝”，  
那么A和B都可以修改商品名称。 但实际上，我们想要的结果应该是只有一个人可以修改。
```
-- 在这种情况可以跟上面一样，使用for update
-- 但是其实这里可以使用别的方式
update goods set name = "垃圾" where id = 123 and name = "宝贝";
-- 因为本身update就是一个原子操作，在执行的时候只要设置好where语句就可以
-- 因为update的返回值是修改的记录数，我们可以根据update的返回值来判断有没有修改成功。
```
> 商品减库存其实可以使用此方法，如果需要减10个库存：
```
update goods set stock = stock - 10 where id = 123 and stock >= 10;
```

4. 原本减库存的操作可以通过数据库级来保证的，但是为什么又扯出来其它事情呢？  
如果只是一个很少人用的系统是可以这样的。但是当用户量很大，比如电商这种场景，  
很多人对同一商品同时下单是很常见的情况，如果把所有都直接操作mysql，那么性能  
会很容易达到瓶颈，所以很多情况下会将扣减库存放在redis中完成，然后定期在将redis中  
的库存数据同步到mysql中。
> redis减库存可以使用lua脚本。或者watch stock

5. 在4中说的只是正常售卖的商品，现在又有很多秒杀商品，会导致并发更高，所以秒杀的商品  
还不能简单的跟4中的商品同样处理。  
> 在秒杀场景下，即使使用了redis，仍然很难一下子承受太多的请求。可以在请求前几串行队列，  
> 同时，秒杀时，用户一般远远大于库存数，所以可以制定一些策略，让部分用户直接在前端就拦截掉，  
> 直接进入到秒杀结束界面。
