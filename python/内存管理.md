### 问题
python是如何管理内存的

### 解决办法
[官方文档内存管理页](https://docs.python.org/3.6/c-api/memory.html?highlight=memory%20Management)  
[官方文档垃圾回收页](https://docs.python.org/3.6/whatsnew/2.0.html?highlight=garbage%20collector#garbage-collection-of-cycles)  

##### 内存分配
1. python有自己实现的内存管理器，一切内存的内存管理都是通过这个管理器来实现的  
> 操作系统自身是有内存管理器的，一般反映到系统调用上就是malloc之类的操作，  
> 但是使用这些调用有一个过程就是从用户态到内核态再到用户态的过程，如果仅仅调用几次没什么，  
> 但是如果每创建一个对象就这么去调用一次，是很影响性能的，所以python自建的内存管理器，  
> 会上来先在内存的堆(堆和栈的区别)中分配一块内存，之后就在这块内存上维护python的对象之类的东西，  
> 如果不够就再去增加，比如使用realloc调用。  

2. python为不同的对象实现了不同的叫object-specific allocators，因为不同类型分配内存的策略不同  

##### 内存回收
> python在创建对象的时候为每个对象维护了一个引用个数的值，并且将所有对象弄到一个链表中管理，   
> 当引用个数为0时，就意味着这个对象占用的内存可以被释放了，  
> 然后就出现了，一直说的循环引用问题，循环引用导致即使删除两个对象都删除了, 但是由于他们相互引用，导致引用个数还都是1.  

实际上python维护了两条对象链表，一个链表是access(可达的，就是引用计数大于0的对象组成)，  
一个链表是inaccess(不可达的，就是引用计数小于等于0的对象组成)  
在删除对象的时候，不仅对自己的引用个数减1，而且还要将对象中引用的别的对象的引用个数减1.  
这样，如果对象的计数为0了，就将对象放到inaccess链表，如果不为0就在access链表。  
然后，查找access链表，看看有没有A对象内部引用了B对象，但是这个B对象却在inaccess表中的情况，  
如果有，那么就把这个B对象重新拿回access链表。  
当所有对象都检查完了，就把inaccess链表上的对象都释放了。  
