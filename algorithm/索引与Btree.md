### 问题
现在很多时候会谈到索引，一说到索引就会说B-/+tree，为什么  
### 解决办法
> 所有计算机中出现的概念都是为了解决实际的问题，而不是凭空出现的。  

1. 首先要明白怎么出现的B-tree，并不是说有一个人平白的就弄一个B-tree结构。  
而是因为，当初在设计文件系统时，在给文件建立索引时想出来的存储结构。  
* 我们一般都知道二叉树，每个结点下最多有两个子树，然后使用二分查找。   
随着数据增多，那么树的高度也随之增加，越是底层的结点，搜索到的越慢。  
因此就出现了多叉树，这样就降低了树的高度。  
* 当文件数据多时，索引本身就变得很大，不可能全部加载到内存中。  
因此索引其实也是以文件的形式放到了磁盘上。但是由于磁盘的读写速度慢，  
我们不可能直接在磁盘上进行查找，还是要将索引加载到内存中查找。然后上面说了，  
不可能完全的加载到内存中，因此就要想一种加载到内存的策略。这就与操作系统有关了。  
> 每种操作系统在管理内存时，都有一个最小管理单元的，  
> 比如，linux是以页为最小管理单元，一般大小为4k。  
> 所以在设计树结点时，就让一个结点占用一个内存页大小，所以一个结点占用的磁盘空间也是同样大小，  
> 在查找时，先将根结点从磁盘读入到内存，这是一次IO操作，然后取下一层其中一个结点到内存，这也是一次IO操作。
> 在操作系统上，IO操作基本上是最慢的了，所以我们要尽量减少IO操作。也就是树的层数越少越好。  
> 现在我们假设B-tree中的一个结点包含的数据如下：
> n个关键字(假设关键字是整型数字)，n个指向实际数据的指针，n + 1个指向子结点的指针，
> 以32位系统为例, n * 4 * 2 + (n + 1) * 4 = 4096，不难算出4k的内存可以在下300多个关键字。  
> 我们看看如果一棵三层的树，最大可以容下多少关键字：300 * 300 * 300 = 27,000,000,  
> 如果是用在文件系统上，也就意味着，这个树不会超过3层。
> 所以在设计时，是根据内存页的大小来设置树的阶的(也就是结点下最大子节点数)。

* 上面是B-tree是怎么设计的，B+tree是在B-tree出现后，进行的改进。  
> 试想，树的结点大小是根据内存页的大小决定的，如果我们不存实际数据的指针，  
> 那么计算方式就变成了，n * 4 + (n + 1) * 4 = 4096，这样4k内存就可以在下500个关键字。  
> 然后将所有实际数据指针都存入叶子节点，这和B-tree的区别就是，B-tree找到关键字时，  
> 就找到了实际数据地址，但是B+tree却需要找到最后的叶子节点，才可以得到实际数据地址。  
> 这样B+tree比B-tree有什么好处？其实如果只是上面这样是没有太多好处的。  
> 在B-tree中，如果是三层的树，但是有些查找可能只用一次IO或者两次IO操作就找到了。  
> 但是在B+tree中，所有查找都需要三次IO操作。从这上看其实是没有好处的。  
> 但是B+tree在数据量更大的时候，由于结点容纳的关键字更多，所以可能B-tree已经需要四层了，  
> 而B+tree还是三层，而且所有查找的时间是稳定的值。  

* 另外B+tree相比B-tree在管理时，由于在叶子节点上拥有所有关键字数据，所以更容易进行一些其它优化操作。  
> 比如我们在mysql中经常用到的，顺序查找id为100及之后的20条数据。  
> 这种情况如果用B-tree，你会发现查找到了id=100的数据后，再查找另外20条数据其实也比较麻烦。  
> 但是在B+tree实现时，叶子结点上每个关键字原本就是已经顺序排好的，  
> 而且可以把每个叶子结点再用另一条链连起来，这样就有了一个按关键字排好序的数据链，  
> 上面的需求很容易完成。  

### 参考资料
https://blog.csdn.net/tongdanping/article/details/79878302  
https://blog.csdn.net/endlu/article/details/51720299  
> 需要参照了这两篇博文，但是其实你在网上搜索的时候，发现大家说的都有问题，  
> 其实写博文的人根本没有了解实质，我现在记录的东西如果上来看是很难看懂的，  
> 需要自己先在网上查找看看，再看我写的才可以。  
